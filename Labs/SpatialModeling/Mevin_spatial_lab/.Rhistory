#function for beta shape parameters#
shape_from_stats <- function(mu, sigma ){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#make a function for the one pool model#
model1 = function(k1,CDI,t)1*exp(-k1*CDI*t)#
#
LL1 = function(y,k1,sigma){#
	#you could embed the model without using a fucntion#
	#Mhat=100*exp(-k1*CDI*t)#
	Mhat = model1(k1,CDI,t)#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
one_pool = mle2(minuslogl = LL1, start = list(k1 = .1, sigma=.01), data = list(y=y))#
summary(one_pool)#
k1.est = coef(one_pool)[1]#
mu = model1(k1.est,CDI,t)#
#
plot(M_t,mu, ylab="Predicted Mass at t", xlab="Observed Masss at t")#
#
#
# R nls estimates#
one_pool2 = nls(M_t ~ 100 * exp(-k1*CDI*t), start = list(k1 = .1))#
summary(one_pool2)#
confint(one_pool2)#
model2 = function(k1,k2,CDI,M1,M2_2, t) M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.01), data = list(y=y))#
attr(two_pool,"df") = attr(two_pool,"df")+1#
summary(two_pool)#
plot(profile(two_pool))#
confint(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.01), data = list(y=y))#
M1#
head(y)#
y[,1]=Y[,1]/100#
Y=read.csv("/Users/Tom/Documents/Ecological Modeling Course/2008 Spring Semester/Labs/Lab 6/LIDET Lab data.csv")#
y[,1]=Y[,1]/100#
y[,4:7]=Y[,4:7]/100#
head(y)#
head(y)#
attach(y)#
plot(t,M_t)#
library(bbmle)#
#
#function for beta shape parameters#
shape_from_stats <- function(mu, sigma ){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#make a function for the one pool model#
model1 = function(k1,CDI,t)1*exp(-k1*CDI*t)#
LL1 = function(y,k1,sigma){#
	#you could embed the model without using a fucntion#
	#Mhat=100*exp(-k1*CDI*t)#
	Mhat = model1(k1,CDI,t)#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
}#
one_pool = mle2(minuslogl = LL1, start = list(k1 = .1, sigma=.01), data = list(y=y))#
summary(one_pool)#
one_pool2 = nls(M_t ~ 100 * exp(-k1*CDI*t), start = list(k1 = .1))#
summary(one_pool2)#
confint(one_pool2)#
#
Y=read.csv("/Users/Tom/Documents/Ecological Modeling Course/2008 Spring Semester/Labs/Lab 6/LIDET Lab data.csv")#
y[,1]=Y[,1]/100#
y[,4:7]=Y[,4:7]/100#
head(y)#
attach(y)#
plot(t,M_t)#
library(bbmle)#
#
#function for beta shape parameters#
shape_from_stats <- function(mu, sigma ){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#make a function for the one pool model#
model1 = function(k1,CDI,t)1*exp(-k1*CDI*t)#
#
LL1 = function(y,k1,sigma){#
	#you could embed the model without using a fucntion#
	#Mhat=100*exp(-k1*CDI*t)#
	Mhat = model1(k1,CDI,t)#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
one_pool = mle2(minuslogl = LL1, start = list(k1 = .1, sigma=.01), data = list(y=y))#
attr(one_pool,"df") = attr(one_pool,"df")+1#
summary(one_pool)#
plot(profile(one_pool))#
#
AIC(one_pool)#
confint(one_pool)#
#
#
#
#plot predicted vs observed#
k1.est = coef(one_pool)[1]#
mu = model1(k1.est,CDI,t)#
#
plot(M_t,mu, ylab="Predicted Mass at t", xlab="Observed Masss at t")#
# R nls estimates#
one_pool2 = nls(M_t ~ 1 * exp(-k1*CDI*t), start = list(k1 = .1))#
summary(one_pool2)#
confint(one_pool2)#
#
model2 = function(k1,k2,CDI,M1,M2_2, t) M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.01), data = list(y=y))#
head(y)#
model2 = function(k1,k2,CDI,M1,M2_2, t) M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.01), data = list(y=y))#
summary(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .9, k2 = .1, sigma=.01), data = list(y=y))#
summary(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .9, k2 = .1, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	browser()#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .9, k2 = .1, sigma=.01), data = list(y=y), control=list(maxit=1000))#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
shape#
shape_from_stats(mu=Mhat, sigma=sigma)[1]#
class(shape)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
Q#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)[1]#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
attr(two_pool,"df") = attr(two_pool,"df")+1#
Q#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)[1]#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	#shape = shape_from_stats(mu=Mhat, sigma=sigma)[1]#
	#return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
two_pool2 = nls(M_t ~ M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t), start = list(k1 = .1, k2= .1))#
summary(two_pool2)#
confint(two_pool2)#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	shape = shape_from_stats(mu=Mhat, sigma=sigma)#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	shape=matrix(nrow=nrow(y),ncol=2)#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	for(i in 1:nrow(y))	  shape[i,] = shape_from_stats(mu=Mhat[i], sigma=sigma)#
   #
	browser()#
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000))#
head(shape)#
sigma#
shape(1,1)/sum(shape[1,])#
shape[1,1]/sum(shape[1,])#
#
shape[1,1]/sum(shape[1,])#
#
shape[1,1]#
shape[1,1]/shape(1,1:2)#
shape[1,1]/shape[1,1:2]#
#
shape[1,1]/shape[1,1:2]#
#
#
shape[1,1:2]#
sum(shape[1,1:2])#
shape[1,1]/sum(shape[1,1:2])#
head(Mhat)#
head(y)#
LL2 = function(y,k1,k2,sigma){#
	shape=matrix(nrow=nrow(y),ncol=2)#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	for(i in 1:nrow(y))	  shape[i,] = shape_from_stats(mu=Mhat[i], sigma=sigma)#
   #
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
Q#
LL2 = function(y,k1,k2,sigma){#
	shape=matrix(nrow=nrow(y),ncol=2)#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	for(i in 1:nrow(y))	  shape[i,] = shape_from_stats(mu=Mhat[i], sigma=sigma)#
   #
	return(-sum(is.finite(dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	shape=matrix(nrow=nrow(y),ncol=2)#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	for(i in 1:nrow(y))	  shape[i,] = shape_from_stats(mu=Mhat[i], sigma=sigma)#
   #
	return(-sum((dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
LL2 = function(y,k1,k2,sigma){#
	#shape=matrix(nrow=nrow(y),ncol=2)#
	#Mhat=M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	#ssq = sum((Mhat - M_t)^2)#
	#sigma = sqrt(ssq/nrow(y))#
	#browser()#
	#for(i in 1:nrow(y))	  shape[i,] = shape_from_stats(mu=Mhat[i], sigma=sigma)#
    shape=shape_from_stats(mu=Mhat,sigma=sigma)#
	return(-sum((dbeta(Mhat,shape[1],shape[2],log = TRUE))))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
#
#
#note that the last character in minuslogl is a lower case L not a 1!#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000)#
)#
summary(two_pool)#
model2 = function(k1,k2,CDI,M1,M2_2, t) M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
LL2 = function(y,k1,k2,sigma){#
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	 shape=shape_from_stats(mu=Mhat,sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.16), data = list(y=y), control=list(maxit=1000))#
two_pool2 = nls(M_t ~ M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t), start = list(k1 = .1, k2= .1))#
summary(two_pool2)#
confint(two_pool2)#
plot(profile(two_pool))#
confint(two_pool)#
plot(profile(two_pool))#
k1.est=coef(two_pool)[1]#
k2.est=coef(two_pool)[2]#
mu=model2(k1.est,k2.est,CDI,M1,M2_2,t)#
plot(M_t,mu, ylab="Predicted Mass at t", xlab="Observed Masss at t")#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .30, k2 = .54, sigma=.01), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.01), data = list(y=y), control=list(maxit=1000))#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.1), data = list(y=y), control=list(maxit=1000))#
summary(two_pool)#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.1), data = list(y=y), control=list(maxit=50000))#
summary(two_pool)#
warnings()#
two_pool2 = nls(M_t ~ M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t), start = list(k1 = .1, k2= .1))#
summary(two_pool2)#
model2 = function(k1,k2,CDI,M1,M2_2, t) M1*exp(-k1*CDI*t) + M2_2*exp(-k2*CDI*t) #
LL2 = function(y,k1,k2,sigma){#
	Mhat=model2(k1,k2,CDI,M1,M2_2,t)#
	 shape=shape_from_stats(mu=Mhat,sigma=sigma)#
	return(-sum(dbeta(Mhat,shape[1],shape[2],log = TRUE)))#
	#return(-sum(dnorm(Mhat,M_t,sigma,log = TRUE)))#
}#
two_pool = mle2(minuslogl = LL2, start = list(k1 = .1, k2 = .1, sigma=.1), data = list(y=y), control=list(maxit=50000))#
summary(two_pool)#
 shape_from_stats(.4,.1)#
6.3^2/2.63^2#
6.3/.91^2#
6.3/2.63^2#
#Orchids.R#
#uniformative prior#
par(mfrow=c(2,1))#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
?par#
#Orchids.R#
#uniformative prior#
par(mfrow=c(2,1),mai=c(5, 5, 4, 2) + 0.1.)#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
#Orchids.R#
#uniformative prior#
par(mfrow=c(2,1),mai=c(5, 5, 4, 2) + 0.1.))#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
par(mfrow=c(2,1),mai=c(5, 7, 4, 2) + 0.1.))#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
#Orchids.R#
#uniformative prior#
par(mfrow=c(2,1),mai=c(5, 10, 4, 2) + 0.1.))#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
#Orchids.R#
#uniformative prior#
par(mfrow=c(2,1),mar=c(5, 4.5, 4, 2) + 0.1.))#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
par(mfrow=c(2,1),mai=c(1,1.5,1,1))#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
#Orchids.R#
#uniformative prior#
par(mfrow=c(1,1),mai=c(1,1.5,1,1))#
#
a=.001#
b=.001#
y=c(2,4,4,2)#
x=seq(0,12,.1)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Uninformative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
#informative prior#
a=6.3^2 /2.63^2#
b=6.3/2.63^2#
y=c(2,4,4,2)#
a.new=a+sum(y)#
b.new=b+length(y)#
x=seq(0,12,.1)#
y=dgamma(x,a,b)#
plot(x,y, typ='l',ylim=c(0.,.5), xlab=expression(lambda), ylab=(expression(paste("P(", lambda, "|y)"))),cex.lab=1.3, col="red", xlim=c(0,15), main ="Informative prior")#
y=dgamma(x,a.new,b.new)#
lines(x,y)#
a.new#
b.new#
a;b#
citation()#
8/308#
dpois(14,lambda=23)#
dpois(15,lambda=23)#
#
?acf#
x=numeric(100)#
x[1]=100#
sd=10#
for( i in 2:100){#
	x[i]=rnomr(1,x[1],sd)#
	}#
for( i in 2:100){#
	x[i]=rnorm(1,x[1],sd)#
	}#
x#
acf(x)#
x=numeric(100)#
x[1]=100#
sd=.1#
for( i in 2:100){#
	x[i]=[x-1]+rnorm(1,x[-1],sd)#
	}#
for( i in 2:100){#
	x[i]=[x-1] + rnorm(1,x[i-1],sd)#
	}#
for( i in 2:100){#
	x[i]=x[i-1] + rnorm(1,x[i-1],sd)#
	}#
x#
for( i in 2:100){#
	x[i]= rnorm(1,x[i-1],sd)#
	}#
x#
acf(x)#
x=numeric(100)#
x[1]=100#
sd=10#
for( i in 2:100){#
	x[i]= rnorm(1,x[i-1],sd)#
	}#
acf(x)#
x=numeric(100)#
x[1]=100#
sd=10#
for( i in 2:100){#
	x[i]= rnorm(1,x[i-1],sd)#
	}#
acf(x)#
x=numeric(100)#
x[1]=100#
sd=50#
for( i in 2:100){#
	x[i]= rnorm(1,x[i-1],sd)#
	}#
acf(x)#
x=numeric(100)#
x[1]=100#
sd=100#
for( i in 2:100){#
	x[i]= rnorm(1,x[i-1],sd)#
	}#
acf(x)#
z=acf(x)#
z#
?acf#
130/25#
library(knitr)#
?load#
?Sweave#
library(xtable)#
data ( airquality )#
names(airquality)[4]="Temp"#
k=kruskal.test ( Ozone ~ Month , data = airquality )#
print(xtable(airquality[1:8,], digits=c(0,0,1,5,2,1,2)),   display=c("s","s","f","f","f","f","f"),#
NA.string="NA",#
include.rownames=FALSE, floating=FALSE)#
x=seq(0,8,.01)#
y=dnorm(x, mean=3,sd=.9)#
pdf(file="/Users/Tom/Documents/Book with Mevin/Manuscript/Figures/Naked Distribution.pdf")#
plot(x,y, xlab="", ylab="", typ="l", lwd.ticks=0, labels=FALSE,lwd=3, frame.plot=FALSE)#
dev.off()#
plot(x,y, xlab="", ylab="", typ="l", lwd.ticks=0, labels=FALSE,lwd=3, frame.plot=FALSE)#
x=seq(0,1,.01)#
x=seq(0,1,.01)#
y=x#
plot(x,y)#
par()#
x=seq(0,8,.01)#
y=dnorm(x, mean=3,sd=.9)#
par(mfrow=c(1,1))#
plot(x,y)#
plot(x,y), xlab="", ylab="", typ="l") #, lwd.ticks=0, labels=FALSE,lwd=3, frame.plot=FALSE)#
plot(x,y, xlab="", ylab="", typ="l") #, lwd.ticks=0, labels=FALSE,lwd=3, frame.plot=FALSE)#
plot(x,y, xlab="", ylab="", typ="l", lwd.ticks=0, labels=FALSE,lwd=3, frame.plot=FALSE)#
plot(x,y, xlab="", ylab="", typ="l", lwd.ticks=0, labels=FALSE,lwd=3)#
plot(x,y, xlab="", ylab="", typ="l", lwd.ticks=0, lwd=3)#
plot(x,y, xlab="", ylab="", typ="l", lwd=3)#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE)#
?plot#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE,bty=1)#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE)#
par#
?par#
par(bty="l")#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE)#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE, lwd.ticks=0)#
pdf(file="/Users/Tom/Documents/Book with Mevin/Manuscript/Figures/Naked Distribution.pdf")#
par(bty="l")#
plot(x,y, xlab="", ylab="", typ="l", lwd=3, labels=FALSE, lwd.ticks=0)#
dev.off()#
8800*2*12#
165/12#
1500000*1.08^5#
1200000^1.08^3#
1200000*1.08^3#
1200000*1.08^3+3*70#
#
530+442#
972 + 90 + 30 + 40#
35/38#
86/91#
z.pi =rbeta(10000,476,42)#
mean(z.pi)#
sd(z.pi)#
z.rho=rbeta(10000,403,15467)#
mean(z.rho)#
sd(z.rho)#
142*.75/12#
log(.5)#
log(5)#
ibrary(xtable)#
library(coda)#
rm(list=ls())#
#root="/Volumes/wcnr-network/Research/Hobbs/A_Bison_Mauscript/Results"#
root =  "/Users/Tom/Documents/YNP_Bison_Manuscript/Results/"#
path = function (stem,r=root){#
return(paste(r,stem, sep=""))#
}#
#
load(path("median of z.Rdata")) #
load(path("Frequency DIC wt.Rdata"))#
load(path("phi_x_out_of_sample.Rdata"))#
load(path("prop_infect_2008.Rdata")) #
load(path("lambda_healthy.Rdata"))#
load(path("lambda_infected.Rdata"))#
#
load(path("Ntotals.Rdata"))#
load(path("diff.con.Rdata")) #
load(path("diff.pos.Rdata"))#
load(path("lambda.diff")) #
load(path("R0.Rdata"))#
load(path("prop.infect.Rdata"))#
load(path("serology.Rdata"))#
load(path("phi_x.Rdata"))#
load(path("parameter_table.Rdata"))#
load(path("Mgmt scenarios forecast table.Rdata"))#
load(path("Mgmt scenarios table.Rdata"))#
load(path("Mgmt scenarios forecast table unc.Rdata"))#
load(path("Mgmt scenarios table unc.Rdata"))#
#
#abstract#
signif(table[1,2],2)#
signif(table[1,4],2)#
signif(table[1,2],2)#
signif(R0_list$meanR0,2)  #####Check this#
signif(R0_list$ci[1],3)#
signif(R0_list$ci[2],3)#
signif(lambda.infected$lambda.mean,3)#
signif(lambda.healthy$lambda.mean,3)#
signif(lambda.healthy$lambda.ci[1],3)#
signif(lambda.healthy$lambda.ci[2],3)#
signif(phi[[1]],2)#
signif(phi[[2]]$stat[2],2)#
signif(prop.infect$pop.x,2)#
signif(prop.infect$pop.ci[1],2)#
signif(prop.infect$pop.ci[2],2)#
signif(table[12,1],2)#
signif(table[12,4],2)signif(table[12,5],2)#
signif(table[6,1],2)*100#
signif(table[6,4],2)*100#
signif(table[6,5],2)*100#
substr(s[14,8],1,4)#
substr(stat.out[12,3],1,4)#
substr(stat.out[12,3],9,11) #
substr(stat.out[12,3],16,19) #
substr(stat.out[12,6],1,4)#
substr(stat.out[12,6],16,20)#
substr(s[35,8],1,4)#
#
table#
signif(table[11,1],2)#
signif(table[11,4],2)#
signif(table[11,5],2)#
#abstract#
signif(table[1,2],2)#
signif(table[1,4],2)#
signif(table[1,2],2)#
signif(R0_list$meanR0,2)  #####Check this#
signif(R0_list$ci[1],3)#
signif(R0_list$ci[2],3)#
signif(lambda.infected$lambda.mean,3)#
signif(lambda.healthy$lambda.mean,3)#
signif(lambda.healthy$lambda.ci[1],3)#
signif(lambda.healthy$lambda.ci[2],3)#
signif(phi[[1]],2)#
signif(phi[[2]]$stat[2],2)#
signif(prop.infect$pop.x,2)#
signif(prop.infect$pop.ci[1],2)#
signif(prop.infect$pop.ci[2],2)#
signif(table[11,1],2)#
signif(table[11,4],2)#
signif(table[11,5],2)#
signif(table[6,1],2)*100#
signif(table[6,4],2)*100#
signif(table[6,5],2)*100#
substr(s[14,8],1,4)#
substr(stat.out[12,3],1,4)#
substr(stat.out[12,3],9,11) #
substr(stat.out[12,3],16,19) #
substr(stat.out[12,6],1,4)#
substr(stat.out[12,6],16,20)#
substr(s[35,8],1,4)#
?median#
median#
?quantile#
?hpdl#
?citation#
citation()#
shape_from_stats <- function(mu, sigma){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
shapes_from_stats(.8,.2)#
shape_from_stats(.8,.2)#
#
.8^2#
shape_from_stats(.8,.02)#
#
#
(.8^2-.8^3-.02^2)/.02^2#
58*70#
(.9+.7+5)*3.1*1.1#
(.9+.7+5)*2.8*1.1#
#
(1.1+.7+5)*2.5*1.05#
x=seq(0,8,.01)#
y=dnorm(x, mean=3,sd=.9)#
plot(x,y, xlab=expression(theta), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("[ ",theta," | data]")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
#
l=qnorm(mean=3 ,sd=.9,.025)#
u=qnorm(mean=3,sd=.9,.975)#
abline(v=l)#
abline(v=u)#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/credible interval.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab=expression(theta), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("[ ",theta," | data]")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
#
l=qnorm(mean=3 ,sd=.9,.025)#
u=qnorm(mean=3,sd=.9,.975)#
abline(v=l)#
abline(v=u)#
dev.off()#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("[ ",italic(theta)," | data]")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("[ ",italic(z)," | data]")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("[ ",italic(\theta)," | data]")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
plot(x,y, xlab="", typ="l", labels=FALSE, space=1.5, ylab=expression""), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
plot(x,y, xlab="", typ="l", labels=FALSE, space=1.5, ylab=""), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
plot(x,y, xlab="", typ="l", labels=FALSE, space=1.5, ylab="", lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/credible interval.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab="", typ="l", labels=FALSE, space=1.5, ylab="", lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
#
l=qnorm(mean=3 ,sd=.9,.025)#
u=qnorm(mean=3,sd=.9,.975)#
abline(v=l)#
abline(v=u)#
dev.off()#
x=seq(0,8,.01)#
y=dnorm(x, mean=3,sd=.9)#
#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/Distribution.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("(",italic(\theta)," | data)")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
dev.off()#
#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/credible interval.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab="", typ="l", labels=FALSE, space=1.5, ylab="", lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
#
l=qnorm(mean=3 ,sd=.9,.025)#
u=qnorm(mean=3,sd=.9,.975)#
abline(v=l)#
abline(v=u)#
dev.off()#
#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/Distribution.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("(",theta," | data)")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
dev.off()#
pdf(file="/Users/Tom/Documents/ SESYNC Seminar/Distribution.pdf", height=5, width=5)#
par(mfrow=c(1,1), mar=c(5, 6, 4, 2) + 0.1)#
plot(x,y, xlab=expression(italic(theta)), typ="l", labels=FALSE, space=1.5, ylab=expression(paste("P(",theta," | data)")), lwd.ticks=0, cex.lab=1.5, lwd=2, col="blue")#
dev.off()#
  V <- cbind( c( 2, .5) , c( .5, 1) )   # what V's are ok?? A: variance matrices#
#
# Properties of 2 x 2 variance matrices#
#   1. symmetric#
#   2. diag elements >= 0#
#   3. satisfy correlation inequality#
#
# The cholesky square root of V#
#
    A <- t( chol( V ) )    # lower triangular matrix#
    A#
    A %*% t(A)#
#
    Y <- t ( mu + A %*% t(Z))#
    #
    apply(Y, 2, mean)#
    var( Y )#
    cor( Y )#
#
    eqscplot(Y)#
z <- rnorm(100)#
    z#
    mean(z)#
    var(z)#
    plot(z)#
    plot( density(z) )#
#
# true density for N(0,1)#
#
    x <- seq( -4, 4, .01)#
    ndens <- 1/sqrt(2*pi) * exp ( -(1/2)* x^2)#
    lines( x, ndens, col = 'red', lwd = 2)#
#
#
###
## repeat a few time#
###
#
    plot( x, ndens , type = 'l', ylim = c(0,.5), col = 'blue', lwd = 2)#
#
# samples of size 30#
#
for ( i in 1:4) {#
   z <- rnorm( 30 )#
   print( i )#
   print ( mean(z))#
   print ( var(z))#
   lines( density( z ), col = 'red', lwd = 1)#
}#
#
# samples of size 300#
#
for ( i in 1:4) {#
   z <- rnorm( 300 )#
   print( i )#
   print ( mean(z))#
   print ( var(z))#
   lines( density( z ), col = 'green')#
}#
# General mean and var#
#
# Sample of 100 with mean 100 and variance 225#
#
    y <- 100 + sqrt( 225 ) * rnorm(100)#
    mean(y)#
    var(y)#
    sd(y)#
    plot( density( y ))#
#
# easier#
#
   ?rnorm#
   rnorm( 100, 100, 15)#
#
#
#
# Standard normal#
#
   Z <- matrix( rnorm( 2 * 100), ncol = 2)#
   Z     # Note: each row is an observation#
   plot( Z )#
#
   apply( Z , 2, mean)#
   var( Z )#
   cor( Z )#
#
   Zs <- scale( Z )     # this standardizes the columns of Z#
   var( Zs )#
#
# Shape of population#
#
    circ <- cbind( cos( seq(0,1,.01) * 2 * pi) , sin ( seq( 0, 1, .01) * 2 * pi))#
    lines( circ)#
#
# why does it not look like a circle#
#
    library(MASS)#
#
    eqscplot( Z )    # ensures that a unit on y axis has same length as unit on x axis#
    lines(circ, col = 'red')#
#
#
# Transformation of Normal#
#
   mu <- c(2,3)#
#
   A <- matrix( c( 1, 0, 1, 1), ncol = 2)#
#
   Y <- t ( mu + A %*% t(Z))  # why the t's ???#
#
#
   apply( Y , 2, mean)#
   var( Y )#
   cor( Y )#
   #
   # population variance ??#
   A %*% t(A)#
#
   eqscplot( Y )#
   lines( t( mu + A %*% t(circ)), col = 'red' )   # population std. ellipse#
   points( 2, 3, col = 'red', pch = 16)#
# Properties of bivariate normal#
#    Marginal and conditional distribution#
# Properties of standard ellipse#
##
#
# Generating a bivariate normal with a given variance matrix V#
# Need to find A such that V = AA'#
#
    V <- cbind( c( 2, .5) , c( .5, 1) )   # what V's are ok?? A: variance matrices#
#
# Properties of 2 x 2 variance matrices#
#   1. symmetric#
#   2. diag elements >= 0#
#   3. satisfy correlation inequality#
#
# The cholesky square root of V#
#
    A <- t( chol( V ) )    # lower triangular matrix#
    A#
    A %*% t(A)#
#
    Y <- t ( mu + A %*% t(Z))#
    #
    apply(Y, 2, mean)#
    var( Y )#
    cor( Y )#
#
    eqscplot(Y)#
#
    # To get the population ellipse#
    # do onto the unit circle as you do onto standard normal#
#
    lines( t( mu + A %*% t(circ)))  # population ellipse#
    #
    # To get the sample ellipse#
    # use the sample mean and the sample variance#
    #
    #
    mu.hat <- apply( Y, 2 , mean)#
    mu.hat#
    #
    lines ( t ( mu.hat + t( chol(var(Y))) %*% t(circ)), col = 'blue')#
#
#
    # Another sample#
    #
    Z <- matrix ( rnorm( 100 * 2), ncol = 2 )#
    Y <- t ( mu + A %*% t(Z) )#
    points( Y, col = 'red')#
#
    mu.hat <- apply( Y, 2 , mean)#
    mu.hat#
#
    lines ( t ( mu.hat + t( chol(var(Y))) %*% t(circ)), col = 'red')#
#
 Easier way#
#
#
#
    library( mvtnorm )   # multivariate T and normal distribution#
    help.start()#
#
#
    mu <- c( 2, 3)#
    V <- matrix( c( 2, 1.3, 1.3, 1), ncol = 2)#
    #
    Y <- rmvnorm( 100, mu, V)    # in library(mvtnorm) [see above]#
    #
    eqscplot( Y )#
#
    lines( ell ( mu , V ))     # from coursefun.R#
#
    lines( dell ( Y ) , col = 'green')   # dell = data ellipse from coursefun.R#
#
#
#
###
##   Multivariate (Tri) Normal#
###
#
   Z <- matrix( rnorm( 3 * 200 ), ncol = 3 )#
#
   colnames(Z) <- paste( "Z", 1:3, sep = "")#
#
   plot3d( Z )#
   plot3d( Z , surface = F, ellipsoid = T)    # NOTE: not eqscplot3d#
#
#
   apply( Z, 2 , mean)#
   var( Z )#
   cor( Z )#
#
#
# Transformation#
#
   A <- cbind( c( 1, 0, 0), c( 1, 1, 0), c( 1, 1, 1))#
   A#
   cov2cor(A %*% t(A))#
   mu <- c( 2,3,-1)#
#
   Y <- t( mu + A %*% t(Z))#
#
   apply( Y, 2, mean )#
   var( Y )#
   cor( Y )#
#
   plot3d( Y, surface = F, ellipsoid = T )#
#
   plot3d( Y, surface = T, ellipsoid = T )#
#
#
# Transformation with independent components#
#
   A <- cbind( c( 2, 0, 0), c( 0, 1, 0 ), c( 0, 1, 1) )#
   A#
   A %*% t(A)#
   mu <- c( 2,3, -1)#
#
   Y <- t( mu + A %*% t(Z))#
#
   apply( Y, 2, mean)#
   var( Y )#
   cor( Y )#
#
   plot3d ( Y, surface = F, ellipsoid = T)#
#
#
# Singular transformation#
#
    solve(A)  # A inverse is okay#
#
#
    A <- cbind ( c( 2, 0, 0), c( 0, 1, 1), c(0, 1, 1))#
    A#
#
    solve( A )#
#
    mu <- c( 2,3, -1)#
#
    Y <- t( mu + A %*% t(Z))#
#
    apply( Y, 2, mean)#
    var( Y )#
    cor( Y )#
#
    plot3d ( Y, surface = F, ellipsoid = T)#
#
library(MASS)#
bivn <- mvrnorm(1000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 2))#
#
# now we do a kernel density estimate#
bivn.kde <- kde2d(bivn[,1], bivn[,2], n = 50)#
# now plot your results#
contour(bivn.kde)#
image(bivn.kde)#
persp(bivn.kde, phi = 45, theta = 30)#
# fancy contour with image#
image(bivn.kde); contour(bivn.kde, add = T)#
#
# fancy perspective#
persp(bivn.kde, phi = 45, theta = 30, shade = .1, border = NA)#
mu1<-0 # set mean x1#
mu2<-0 # set mean x2#
s11<-10 # set variance x1#
s22<-10 # set variance x2#
s12<-15 # set covariance x1 and x2#
rho<-0.5 # set correlation coefficient  x1 and x2#
x1<-seq(-10,10,length=41) # generate vector  x1#
x2<-x1 # copy x1 to x2#
#
#
f<-function(x1,x2) # multivariate function#
{#
term1<-1/(2*pi*sqrt(s11*s22*(1-rho^2)))#
term2<--1/(2*(1-rho^2))#
term3<-(x1-mu1)^2/s11#
term4<-(x2-mu2)^2/s22#
term5<--2*rho*((x1-mu1)*(x2-mu2))/(sqrt(s11)*sqrt(s22))#
term1*exp(term2*(term3+term4-term5))#
} #
#
z<-outer(x1,x2,f) # calculate density values#
#
#
persp(x1, x2, z, # 3-D plot#
main="Two dimensional Normal Distribution",#
sub=expression(italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~#
sigma[22]~(1-rho^2)))~phantom(0)^bold(.)~exp~bgroup("{",#
list(-frac(1,2(1-rho^2)),#
bgroup("[", frac((x[1]~-~mu[1])^2, sigma[11])~-~2~rho~frac(x[1]~-~mu[1],#
sqrt(sigma[11]))~ frac(x[2]~-~mu[2],sqrt(sigma[22]))~+~#
frac((x[2]~-~mu[2])^2, sigma[22]),"]")),"}")),#
col="lightgreen",#
theta=30, phi=20,#
r=50,#
d=0.1,#
expand=0.5,#
ltheta=90, lphi=180,#
shade=0.75,#
ticktype="detailed",#
nticks=5) #
plot(x1,x2)#
 # R code to create bivariate figure#
mu1<-0 # set mean x1#
mu2<-3 # set mean x2#
s11<-10 # set variance x1#
s22<-10 # set variance x2#
s12<-15 # set covariance x1 and x2#
rho<-0.5 # set correlation coefficient  x1 and x2#
x1<-seq(-10,10,length=41) # generate vector  x1#
x2<-x1 # copy x1 to x2#
#
#
f<-function(x1,x2) # multivariate function#
{#
term1<-1/(2*pi*sqrt(s11*s22*(1-rho^2)))#
term2<--1/(2*(1-rho^2))#
term3<-(x1-mu1)^2/s11#
term4<-(x2-mu2)^2/s22#
term5<--2*rho*((x1-mu1)*(x2-mu2))/(sqrt(s11)*sqrt(s22))#
term1*exp(term2*(term3+term4-term5))#
} #
#
z<-outer(x1,x2,f) # calculate density values#
#
#
persp(x1, x2, z, # 3-D plot#
main="Two dimensional Normal Distribution",#
sub=expression(italic(f)~(bold(x))==frac(1,2~pi~sqrt(sigma[11]~#
sigma[22]~(1-rho^2)))~phantom(0)^bold(.)~exp~bgroup("{",#
list(-frac(1,2(1-rho^2)),#
bgroup("[", frac((x[1]~-~mu[1])^2, sigma[11])~-~2~rho~frac(x[1]~-~mu[1],#
sqrt(sigma[11]))~ frac(x[2]~-~mu[2],sqrt(sigma[22]))~+~#
frac((x[2]~-~mu[2])^2, sigma[22]),"]")),"}")),#
col="lightgreen",#
theta=30, phi=20,#
r=50,#
d=0.1,#
expand=0.5,#
ltheta=90, lphi=180,#
shade=0.75,#
ticktype="detailed",#
nticks=5) #
library(MASS)#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
Sigma#
var(mvrnorm(n=100, rep(0, 2), Sigma))#
var(mvrnorm(n=1000, rep(0, 2), Sigma, empirical = TRUE))#
mvrnorm(n=100, rep(0, 2), Sigma)#
x=mvrnorm(n=100, rep(0, 2), Sigma)#
x#
plot(x[1],x[2])#
plot(x[1,],x[2,])#
plot(x[,1],x[,2])#
x=mvrnorm(n=1000, rep(0, 2), Sigma)#
plot(x[,1],x[,2])#
hist(x[,1])#
x=mvrnorm(n=10000, rep(0, 2), Sigma)#
plot(x[,1],x[,2])#
hist(x[,1])#
x=mvrnorm(n=3, rep(0, 2), Sigma)#
x#
x=mvrnorm(n=3, rep(0, 2), Sigma)/3#
x#
x=mvrnorm(n=3, rep(0, 2), Sigma)/9#
x#
?mvnorm#
?mvrnorm#
p=x/sum(rowSums(x))#
p#
p=mvdnorm(x)#
?mvrnorm#
x=mvrnorm(100, mu = c(1, 3), Sigma = matrix(c(1, .5, .5, 1), 1))#
library(MASS)#
#
x=mvrnorm(100, mu = c(1, 3), Sigma = matrix(c(1, .5, .5, 1), 1))#
bivn <- mvrnorm(100, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1))#
bivn2 <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1), 1))#
bivn <- mvrnorm(100, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1))#
bivn2 <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1), 1))#
bivn2 <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1), ))#
bivn2 <- mvrnorm(10000, mu = c(0, 0), Sigma = matrix(c(1, .5, .5, 1), 1))#
?mvnorm#
?mvrnorm#
Sigma <- matrix(c(10,3,3,2),2,2)#
Sigma#
var(mvrn#
Sigma <- matrix(c(10,3,3,2),2,2)#
Sigma#
plot(x[,1]x[,2])#
plot(x[,1],x[,2])#
x=mvrnorm(n=1000, rep(0, 2), Sigma))#
x=mvrnorm(n=1000, rep(0, 2), Sigma)#
plot(x[,1],x[,2])#
plot(x[,1],x[,2],pch=19,cex=.1)#
plot(density(x[,1]))#
x=mvrnorm(n=1000, mu=c(1,3), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1)#
x=mvrnorm(n=10000, mu=c(1,3), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1)#
plot(density(x[,1]))#
hist(denstiy(x[,1]))#
hist(x[,1])#
hist(x[,1],Freq=FALSE)#
hist(x[,1],FREQ=FALSE)#
?hist#
hist(x[,1],freq=FALSE)#
hist(x[,1],freq=FALSE, lyab="[x]",xlab="x")#
hist(x[,1],freq=FALSE, yab="[x]",xlab="x")#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x")#
Sigma <- matrix(c(10,3,3,2),2,2)#
Sigma#
x=mvrnorm(n=10000, mu=c(1,5), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1)#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="")#
plot(density(x[,1])#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y")#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", xlim=c(0,12),ylim=c(0,12))#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y",xlim=c(0,12),ylim=c(0,12))#
x=mvrnorm(n=10000, mu=c(0,2), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y",xlim=c(0,12),ylim=c(0,12))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", )#
plot(density(x[,1])#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y")#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
lines(density(x[,1])#
)#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", )#
lines(density(x[,1])#
)#
x=mvrnorm(n=100000, mu=c(0,2), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", )#
lines(density(x[,1])#
lines(density(x[,1],adjust=2)#
x=mvrnorm(n=10000, mu=c(0,2), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", )#
lines(density(x[,1],adjust=2)#
)#
hist(x[,2],freq=FALSE, ylab="[x]",xlab="x",main="", )#
lines(density(x[,2],adjust=2))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=50)#
lines(density(x[,1],adjust=2)#
)#
hist(x[,2],freq=FALSE, ylab="[x]",xlab="x",main="",xlim=c(-12,12) ,breaks=50)#
lines(density(x[,2],adjust=1))#
plot(density(x[,2],adjust=1))#
plot(density(x[,2],adjust=2))#
hist(x[,2],freq=FALSE, ylab="[y]",xlab="y",main="",xlim=c(-12,12) ,breaks=25)#
plot(density(x[,2],adjust=2), lwd=2)#
hist(x[,2],freq=FALSE, ylab="[y]",xlab="y",main="",xlim=c(-12,12) ,breaks=25)#
lines(density(x[,2],adjust=2), lwd=2)#
plot(x[,1],x[,2],pch=19,cex=.1, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=25)#
lines(density(x[,1],adjust=2)#
)#
lines(density(x[,1],adjust=2), lwd=2)#
xy<- kde2d(x[,1], x[,2], n = 50)#
persp(xy, phi = 45, theta = 30, shade = .2, border = NA)#
x=mvrnorm(n=100000, mu=c(0,2), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.01, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=25)#
lines(density(x[,1],adjust=2), lwd=2)#
hist(x[,2],freq=FALSE, ylab="[y]",xlab="y",main="",xlim=c(-12,12) ,breaks=25)#
lines(density(x[,2],adjust=2), lwd=2)#
#
#
# now we do a kernel density estimate#
xy<- kde2d(x[,1], x[,2], n = 50)#
#
# fancy perspective#
persp(xy, phi = 45, theta = 30, shade = .2, border = NA)#
persp(bivn.kde2, phi = 45, theta = 30, shade = .1, border = NA)#
?persp#
persp(x=x[,1], y=x[,2] z=xy, phi = 45, theta = 30, shade = .2, border = NA)#
persp(x=x[,1], y=x[,2], z=xy, phi = 45, theta = 30, shade = .2, border = NA)#
mu <- c(0,2)#
#
x <- y <- seq(-12, 12, len=100)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
bivariate.normal <- function(x, mu, Sigma) {#
exp(-.5*t(x-mu)%*%solve(Sigma)%*%(x-mu))/sqrt(2*pi*det(Sigma))#
}#
#
mu <- c(0,2)#
#
x <- y <- seq(-12, 12, len=100)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, shade=.05, col="grey", main="Bivariate Normal Density", phi=45,theta=30)#
persp(x, y, z, shade=0., col="grey", main="Bivariate Normal Density", phi=45,theta=30)#
?filled.contour#
?persp#
persp(x, y, z, , col="white",, phi=45,theta=30)#
x=mvrnorm(n=10000, mu=c(0,2), Sigma)#
plot(x[,1],x[,2],pch=19,cex=.01, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=25)#
lines(density(x[,1],adjust=2), lwd=2)#
hist(x[,2],freq=FALSE, ylab="[y]",xlab="y",main="",xlim=c(-12,12) ,breaks=25)#
lines(density(x[,2],adjust=2), lwd=2)#
#
#
bivariate.normal <- function(x, mu, Sigma) {#
exp(-.5*t(x-mu)%*%solve(Sigma)%*%(x-mu))/sqrt(2*pi*det(Sigma))#
}#
#
mu <- c(0,2)#
#
x <- y <- seq(-12, 12, len=100)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
#
x <- y <- seq(-12, 12, len=50)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
x <- y <- seq(-5, 5, len=50)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
#
x <- y <- seq(-10, 10, len=50)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
#
x <- y <- seq(-10, 10, len=5)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
x <- y <- seq(-10, 10, len=25)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
x <- seq(-10,10, length=25); y<- seq(-5, 5, len=25)#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
par(mfrow=c(1,1))#
persp(x, y, z, , col="white",, phi=45,theta=30)#
x <- seq(-10,10, length=50); y<- seq(-5, 5, len=50)#
# Evaluate the bivariate normal density for each value of x and y#
z <- outer(x, y,#
FUN=function(x, y, ...){#
apply(cbind(x,y), 1, bivariate.normal, ...)#
}, mu=c(0,0), Sigma=Sigma)#
# Filled contour and surface plot of the bivariate normal density#
filled.contour(x,y,z, main="Bivariate Normal Density", color.palette=topo.colors)#
persp(x, y, z, , col="white",, phi=45,theta=30)#
?persp#
persp(x, y, z, , col="white",, phi=45,theta=30, xlab="x", ylab="y", zlab="[x,y]")#
axplot=function(x=NULL, y=NULL, xlim=NULL, ylim=NULL, xlab="x", ylab="y", xfont=NULL, yfont=NULL, typ="p", col="black", lty="solid",#
pch=19, space=2, main="", xaxt="s", yaxt="s", labels=TRUE, lwd.ticks=.5, pos=c(0,0), graph_type="plot", breaks=NULL, freq=FALSE){	  #
	if(graph_type == "plot"){#
	plot(x,y, ylim=ylim, xlim=xlim, lwd=1, typ=typ, pch=pch, axes=FALSE, xlab="", ylab="", main=main, col=col, lty=lty)#
	axis(side=1,lwd=.5, pos=pos,  cex.axis=.75, xaxt=xaxt, labels=labels, lwd.ticks=lwd.ticks)#
	axis(side=2,lwd=.5, pos=pos, cex.axis=.75, labels=labels, lwd.ticks=lwd.ticks)#
	mtext(text = xlab, 1, space , family=xfont )#
	mtext(text=ylab, 2,space,family=yfont)#
	}#
	else{#
		hist(x, axes=FALSE, xlab="", ylab="", main=main, breaks=breaks, freq=freq)#
	axis(side=1,lwd=.5, pos=pos,  cex.axis=.75, xaxt=xaxt, labels=labels, lwd.ticks=lwd.ticks)#
	axis(side=2,lwd=.5, pos=pos, cex.axis=.75, labels=labels, lwd.ticks=lwd.ticks)#
	mtext(text = xlab, 1, space , family=xfont )#
	mtext(text=ylab, 2,space,family=yfont)#
		#
		}#
	#
	}#
par(ps = font_size, cex = 1, cex.main = 1)#
#
#
beta_shape_from_stats <- function(mu, sigma){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- list(a=a,b=b)#
		return(shape_ps)#
}#
#
font_size=9#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
Sigma#
x=mvrnorm(n=10000, mu=c(0,2), Sigma)#
axplot(x[,1],x[,2],pch=19,cex=.01, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
par(ps = font_size, cex = .01)#
axplot(x[,1],x[,2],pch=19, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10))#
axplot(x[,1],x[,2],pch=19, xlab="x",ylab="y", xlim=c(-10,10), ylim=c(-10,10), labels=TRUE)#
axplot(x[,1],x[,2],pch=19, xlim=c(-10,10),ylim=c(-10,10), labels=TRUE)#
axplot(c(1,2,3),c(1,2,3))#
ty = function(y) max(y)+.2*max(y)#
par(mfrow=c(1,3))#
# default par(mar=c(5, 4, 4, 2) + 0.1.))#
par(mar=c(5,4,2,2)+.01)#
x=seq(0,8,.01)#
#
y=dnorm(x, mean=3,sd=.9)#
#plot(x,y,typ='l', bty="l", xaxt="n", yaxt="n", xlab=expression(italic(dot(z))), lwd=1, col="black",ylab="Probability density", cex.lab=1.3, ylim=c(0,ty(y)), main = "A. Process model")#
axplot(x,y, xlab=expression(italic(dot(z))), ylim=c(0,ty(y)), xfont="Times", typ="l", labels=FALSE, space=1.5, ylab="Probability density", lwd.ticks=0, main="A. Process model")#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(8,12), Sigma)#
axplot(x[,1],x[,2],pch=19, xlim=c(-10,10),ylim=c(-10,10), labels=TRUE)#
par(ps = font_size, cex = .01, mfrow=c(1,1))#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
par(ps = font_size, cex = .01, mfrow=c(1,1))#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
par#
par()#
par$cex#
par()#
par(ps = font_size, cex = .01, mfrow=c(1,1))#
par$cex#
par#
par()#
?par#
par(ps = font_size, cex = .1, mfrow=c(1,1))#
par()#
par(ps = 10, cex = .1, mfrow=c(1,1))#
par()#
par(cex=.01)#
par()#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(8,12), Sigma)#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
par(cex=.1)#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(8,12), Sigma)#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(20,30), Sigma)#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
par(cex=1)#
par(cex=1)#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(20,30), Sigma)#
axplot(x[,1],x[,2],pch=19,  labels=TRUE)#
ty = function(y) max(y)+.2*max(y)#
par(mfrow=c(1,3))#
# default par(mar=c(5, 4, 4, 2) + 0.1.))#
par(mar=c(5,4,2,2)+.01)#
x=seq(0,8,.01)#
#
y=dnorm(x, mean=3,sd=.9)#
#plot(x,y,typ='l', bty="l", xaxt="n", yaxt="n", xlab=expression(italic(dot(z))), lwd=1, col="black",ylab="Probability density", cex.lab=1.3, ylim=c(0,ty(y)), main = "A. Process model")#
axplot(x,y, xlab=expression(italic(dot(z))), ylim=c(0,ty(y)), xfont="Times", typ="l", labels=FALSE, space=1.5, ylab="Probability density", lwd.ticks=0, main="A. Process model")#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=25)#
par(ps = font_size, cex = .1, mfrow=c(1,1))#
par(cex=.1)#
library(MASS)#
Sigma <- matrix(c(10,3,3,2),2,2)#
x=mvrnorm(n=10000, mu=c(20,30), Sigma)#
axplot(x[,1],x[,2],pch=19,  labels=TRUE, )#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", ,xlim=c(-12,12), breaks=25)#
hist(x[,1],freq=FALSE, ylab="[x]",xlab="x",main="", breaks=25)#
max(x[,1])#
max(x[,2])#
axplot(x[,1],x[,2],pch=19,  labels=TRUE,xlim=c(0,35),ylim=c(0,35))#
par()#
plot(c(1,2),c(1,2))#
(s^2)^-(1/2)#
?dbin#
?dbinom#
rgamma(1,.221^2/.0061,.221/.0061)#
rgamma(1,.221^2/.0061,.221/.0061)#
#
a=dgamma(.221, .151^/.0061,.151/.0061)#
a=dgamma(.221, .151^2/.0061,.151/.0061)#
a#
b=dgamma(..151, .221^2/.0061,..221/.0061)#
b=dgamma(.151, .221^2/.0061,..221/.0061)#
b#
b=dgamma(.151, .221^2/.0061,..221/.0061)#
b=dgamma(.151, .221^2/.0061,.221/.0061)#
b#
a/b#
b/a#
mean(y)#
b/a*205/7.22#
b/a*2.05/7.22#
a#
b#
y=c(.32,.32,.15,.12,.21)#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))* dnorm(.221,0,10)#
y#
prod(dnorm(y,mean=.171, sd = sqrt(.0061) ))* dnorm(.171,0,10)#
251/7.89#
2.51/7.89#
y#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))* dnorm(.221,0,10)#
prod(dnorm(y,mean=.171, sd = sqrt(.0061) ))* dnorm(.171,0,10)#
rgamma(1,.221^2/.02,.221/.02)#
b/a*2.51/7.89#
b#
a#
4.42/2.50*2.51/2.43#
b/a*2.51/4.43#
a/b#
a#
b#
2.51/7.89*#
a#
b#
a=dgamma(.221, .191^2/.0061,.191/.0061)#
b=dgamma(.191, .221^2/.0061,.221/.0061)#
a#
b#
a/b#
a/b*2.51/7.89#
a#
b#
2.51/7.89*4.07/5.39#
2.51/7.89#
prod(dnorm(y,mean=.171, sd = sqrt(.0061) ))* dnorm(.171,0,10)#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))* dnorm(.221,0,10)#
2.51/7.89#
3.09*65^-.33#
1.375*65^-.315#
A=matrix(nrow=2,ncol=2)#
A=matrix(nrow=2,ncol=2)#
A[1,1]=0#
A[1,2]=.78#
A[2,1]=.85#
A[2,2]=.85#
eigen(A)#
exp(1.375*65^-.315)#
A=matrix(nrow=2,ncol=2)#
A[1,1]=0#
A[1,2]=.78#
A[2,1]=.9#
A[2,2]=.9#
#
eigen(A)#
A=matrix(nrow=2,ncol=2)#
A[1,1]=0#
A[1,2]=.90^(1/2)*.78#
A[2,1]=.9#
A[2,2]=.9#
#
eigen(A)#
.10*.40#
age=c(.10,.20,.40,.10,.20,.40,.30)#
sero=c(.60,.60,.60,.40,.40,.40,.30)#
age*sero*100#
sum(age*sero*100)#
age_1=c(.10,.20,.40,.30)#
sum(age_1*100)#
age=c(.10,.20,.40,.10,.20,.40)#
sero=c(.60,.60,.60,.40,.40,.40)#
sum(age*sero*70)#
sum(age*100)#
age*sero#
sum(age*sero)#
sum(age*sero)*100#
infc = c(1,1,1,1,1,.25,.75)#
sum(age*sero)*100   #70 females removed#
sum(age*sero*infc)*100#
infc = c(1,1,1,1,1,.25,.75)#
lengt(sero)#
length(sero)#
age=c(.10,.20,.40,.10,.20,.40,.40)#
sero=c(.60,.60,.60,.40,.40,.40,.40)#
infc = c(1,1,1,1,1,.25,.75)#
sum(age*sero*infc)*100#
age=c(.10,.20,.40,.10,.20,.40,.40,.30)#
sero=c(.60,.60,.60,.40,.40,.40,.40,.30)#
age=c(.10,.20,.40,.10,.20,.40,.40,.30)#
sero=c(.60,.60,.60,.40,.40,.40,.40,1)#
infc = c(1,1,1,1,1,.25,.75,1)#
sum(age*sero*infc)*100#
()age*sero*infc*100)#
(age*sero*infc*100)#
(age*sero*infc*100)/10000#
#assuume 100 total removed#
age_1=c(.10,.20,.40,.30)#
#
#
age=c(.10,.20,.40,.10,.20,.40,.40,.30)#
sero=c(.60,.60,.60,.40,.40,.40,.40,1)#
infc = c(1,1,1,1,1,.25,.75,1)#
#check to see if sum to 100#
sum(age*sero*infc)*100#
#
#proportion of removals#
#
#10000 in popuation#
#
#proportions removed#
#
(age*sero*infc*100)/10000#
1.2*8#
11.2*10#
1.2*10#
L=1.2#
n=10#
R=2#
q=.3#
(L^.q*n-R)*L^(1-q)#
(L^q*n-R)*L^(1-q)#
q=1#
(L^q*n-R)*L^(1-q)#
L=1.2#
n=10#
R=2#
q=0#
(L^q*n-R)*L^(1-q)#
L=1.2#
n=10#
R=2#
q=.3#
(L^q*n-R)*L^(1-q)#
568360+488044#
568360+488044 + 90000 + 80000#
#
1.7*1.06^7#
2.5*.04#
2500000*.04#
165000/12#
165000/12*2*1.175#
#
165000/12*2*1.175*1.20#
#
#
?runjags#
dunif(.1,0,1)#
sqrt(1/2*25)#
sqrt(1/12*25)#
18/619#
(1-.05)^8#
1-(1-.05)^8#
lambda=exp(.2-.2/100*n)#
n=seq(0,100)#
plot(n,lambda)#
n#
lambda=exp(.2-.2/100*n)#
lambda#
plot(n,lambda)#
n=seq(0,200)#
lambda=exp(.2-.2/100*n)#
plot(n,lambda)#
plot(n,expresssion,typ="l")#
plot(n,expression(lambda),typ="l")#
plot(n,lambda,expression(lambda),typ="l")#
plot(n,lambda, xlab=expression(lambda),typ="l")#
?plotmath#
plot(n,lambda, ylab=expression(lambda),typ="l")#
plot(n,n*lambda)#
plot(n,n*lambda-n)#
plot(n,n*lambda-n,typ=l,ylab="Surlpus",ylim=c(0,30))#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",ylim=c(0,30))#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100))#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=0,10)#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=c(0,10))#
n=seq(0,200)#
lambda=exp(.4-.4/100*n)#
plot(n,lambda, ylab=expression(lambda),typ="l")#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=c(0,10))#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=c(0,15))#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
plot(n,lambda, ylab=expression(lambda),typ="l")#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=c(0,15))#
plot(n,n*lambda-n,typ="l",ylab="Surlpus",xlim=c(0,100),ylim=c(0,30))#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
plot(n,lambda, ylab=expression(lambda),typ="l")#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
abline(h=1)#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
abline(h=1)#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
abline(h=1, lyt="dotted")#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
abline(h=1, lty="dotted")#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
#
k=100#
r=.4#
#
h=n*(-1+exp(r*(K-1)/K))/exp(r*(K-1)/K)#
K=100#
r=.4#
#
h=n*(-1+exp(r*(K-1)/K))/exp(r*(K-1)/K)#
h#
plot(n,h)#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h)#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
h#
plot(n,h)#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K,lty="l", xlim=c(0,100)#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K#
)#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h, lty="l", xlim=c(0,100)#
)#
plot(n,h, lty="l", xlim=c(0,100))#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h)#
plot(n,h, lty="l", xlim=c(0,100))#
plot(n,h, typ="l", xlim=c(0,100))#
plot(n,h, typ="l", xlim=c(0,100),ylim=0,20)#
plot(n,h, typ="l", xlim=c(0,100),ylim=c(0,20)#
)#
K=100#
r=.8#
#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h, typ="l", xlim=c(0,100),ylim=c(0,20)#
)#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
abline(h=1, lty="dotted")#
plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
#
lambda=.8#
#
#
K=100#
r=1.1#
#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h, typ="l", xlim=c(0,100),ylim=c(0,20))#
n=seq(0,200)#
lambda=exp(.8-.8/100*n)#
par(mfrow=c(1,2))#
plot(n,lambda, ylab=expression(lambda),typ="l")#
abline(h=1, lty="dotted")#
#plot(n,n*lambda-n,typ="l",ylab="Sustainable harvest",xlim=c(0,100),ylim=c(0,30))#
#
lambda=.8#
#
#
K=100#
r=1.1#
#
h=n*(-1+exp(r*(K-n)/K))/exp(r*(K-n)/K)#
plot(n,h, typ="l", xlim=c(0,100),ylim=c(0,30), ylab="Sustanable harvest")#
?citation#
citation()#
ls#
ls()#
stat.out#
?negbinomial#
?dnbinom#
(180-50)*.70 + 50#
upper=(max-rest)*.75+rest#
lower=(max-rest)*.55+rest#
max=180#
rest=50#
#
#zone#
#
upper=(max-rest)*.75+rest#
lower=(max-rest)*.55+rest#
upper#
lower#
upper=(max-rest)*.75+rest#
lower=(max-rest)*.55+rest#
upper#
lower#
#zone based on maximum heart rate#
upper=max*.75#
lower = max*.55#
upper#
lower#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*.75+rest#
	lower_work=(max-rest)*.55+rest#
	upper_max=(max-rest)*.75+rest#
	lower_max=(max-rest)*.55+rest#
	zone=list{upper=upper_max,lower=lower_work}#
	retrun(zone)#
	}#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*.75+rest#
	lower_work=(max-rest)*.55+rest#
	upper_max=(max-rest)*.75+rest#
	lower_max=(max-rest)*.55+rest#
	zone=list(upper=upper_max,lower=lower_work)#
	retrun(zone)#
	}#
#
zone()#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*.75+rest#
	lower_work=(max-rest)*.55+rest#
	upper_max=(max-rest)*.75+rest#
	lower_max=(max-rest)*.55+rest#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*.75+rest#
	lower_work=(max-rest)*.55+rest#
	upper_max*.75#
	lower_max*.55#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*.75+rest#
	lower_work=(max-rest)*.55+rest#
	upper_max=max*.75#
	lower_max=max*.55#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
#
(max-rest)*.55+rest#
max=180#
rest=50#
U=.75#
L=.55#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*U+rest#
	lower_work=(max-rest)*L+rest#
	upper_max=max*U#
	lower_max=max*L#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
max=180#
rest=50#
U=.85#
L=.75#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*U+rest#
	lower_work=(max-rest)*L+rest#
	upper_max=max*U#
	lower_max=max*L#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
max=180#
rest=50#
U=.95#
L=.85#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*U+rest#
	lower_work=(max-rest)*L+rest#
	upper_max=max*U#
	lower_max=max*L#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
max=180#
rest=50#
U=.85#
L=.75#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*U+rest#
	lower_work=(max-rest)*L+rest#
	upper_max=max*U#
	lower_max=max*L#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
max=180#
rest=44#
U=.75#
L=.55#
#zone based on working heart rate#
zone=function(max=180, rest=50){#
	upper_work=(max-rest)*U+rest#
	lower_work=(max-rest)*L+rest#
	upper_max=max*U#
	lower_max=max*L#
	zone=list(upper=upper_max,lower=lower_work)#
	return(zone)#
	}#
#
zone()#
#
#
#
upper=(max-rest)*.75+rest#
lower=(max-rest)*.55+rest#
upper#
lower#
#zone based on maximum heart rate#
upper=max*.75#
lower = max*.55#
upper#
lower#
zone(180,44)#
3.2/(3.2 +11.36)#
library boot#
library(boot)#
logit(-5)#
logit(.8)#
invlogit(-5)#
inv.logit(-5)#
inv.logit(-.2)#
logit(.450166)#
950-789#
136/.76#
.0034^2#
shape_from_stats <- function(mu , sigma ){#
#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
#
		shape_ps <- c(a,b)#
#
		return(shape_ps)#
#
}#
#
a=shape_from_stats(mu=.7,sigma=.07)#
#
#check the function#
#
y=rbeta(10000,a[1],a[2])#
#
mean(y)#
#
sd(y)#
#
#plot the beta distributoin#
#
x=seq(0,1,.01)#
#
y=dbeta(x,a[1],a[2]) #beta density function#
#
plot(x,y,typ="l", xlab="y", ylab="P(y)")#
#
#
#
#function for moment matching in either direction#
#
mm <- function(x1,x2,flag){#
#
		if (flag=="shapes"){#
#
			mu=x1#
#
			sigma=x2#
#
			a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
#
		 	b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
#
			shape_ps <- c(a,b)#
#
			return(shape_ps)#
#
						} #end of shape if#
#
			#
#
		if(flag == "moments"){#
#
			a=x1#
#
			b=x2#
#
			mu=a/(a+b)#
#
			var=a*b/((a+b)^2*(a+b+1))#
#
			shape_ps <- c(mu,var)#
#
			return(shape_ps)#
#
					} #end of moments if#
#
	} #end of function#
#
#get shapes	#
#
a=mm(x1=.7,x2=.07,flag="shapes")#
#
#plot the beta distributoin#
#
x=seq(0,1,.01)#
#
y=dbeta(x,a[1],a[2]) #beta density function#
#
plot(x,y,typ="l", xlab="y", ylab="P(y)")#
#
#get moments#
#
b=mm(x1=a[1],x2=a[2],flag="moments")#
#
mu=b[1]#
#
sd=sqrt(b[2])#
#
mu=exp(-.01*30)#
sd=sqrt(6E-04)#
#
mm(mu, sd, flag="shapes")#
#
momments=mm(17+1,80-17+1, "moments")#
momments#
qbeta(.95,1+17,1+80-17)#
qbeta(.975,1+17,1+80-17)#
#
qbeta(.975,1+17,1+80-17)#
#
#
qbeta(.025,1+17,1+80-17)#
#
#
#
(220+210)/110#
(220+210)/210#
#
I=seq(0,100)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.8#
#
alpha_0=-40#
alpha1 = 1.2#
#
I=seq(0,100)#
#
plot(beta_0+beta1*I)#
plot(beta_0+beta_1*I)#
plot(beta_0+beta_1*I, typ="l")#
lines(gamma_0+gamma_1*I)#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200))#
lines(gamma_0+gamma_1*I)#
I=seq(0,500)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200))#
lines(gamma_0+gamma_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.6#
#
alpha_0=-40#
alpha1 = 1.2#
#
I=seq(0,500)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200))#
lines(gamma_0+gamma_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.3#
#
alpha_0=-40#
alpha1 = 1.2#
#
I=seq(0,500)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200))#
lines(gamma_0+gamma_1*I)#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,500))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
alpha_1 = 1.2#
lines(alpha_0+alpha_1*I)#
alpha_0=-200#
alpha_1 = 1.2#
#
I=seq(0,500)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,500))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.3#
#
alpha_0=-300#
alpha_1 = .8#
#
I=seq(0,500)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,500))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.3#
#
alpha_0=-300#
alpha_1 = .6#
#
I=seq(0,700)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,700))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.1.5#
#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
gamma_1=1.5#
#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.2#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=100#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = -.5#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
beta_0=30#
beta_1 = -.1#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = -.05#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
GNP=FI+MI+SI#
FI=beta_0+beta_1*I#
MI=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
plot(GNP,I)#
plot(GNP,I, typ="l")#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,5000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,1000))#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,5000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,200), xlim=c(0,2000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
lines(GNP,I)#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
lines(GNP,I)#
FI#
Impact=FI*Ef + MI*Em + SI*Es#
plot(I,Impact)#
Impact=max(0,FI*Ef) + max(0,MI*Em) + max(0,SI*Es)#
plot(I,Impact)#
Fimpact=max(0,beta_0+beta_1*I*Ef)#
Mimpact=max(0,gamma_0+gamma_1*I*Em)#
Simpact=max(0+alpha_0+alpha_1*I*Es)#
Total_impact=sum(Fimpact,Mimpact,Simpact)#
plot(I,Total_Impact)#
Total_impact=sum(Fimpact,Mimpact,Simpact)#
plot(I,Total_Impact)#
plot(I,Total_impact)#
#
#
F_i=max(0,beta_0+beta_1*I*Ef)#
M_i=max(0,gamma_0+gamma_1*I*Em)#
S_i=max(0,alpha_0+alpha_1*I*Es)#
T_i=sum(Fimpact,Mimpact,Simpact)#
length(T_i)#
length(F_i)#
F_i=beta_0+beta_1*I*Ef#
F_i#
M_i=gamma_0+gamma_1*I*Em#
M_i#
M_i[M_i<0]=0#
S_i=alpha_0+alpha_1*I*Es#
S_i[S_i,0]=0#
S_i=alpha_0+alpha_1*I*Es#
S_i[S_i<0]=0#
T_i=sum(Fimpact,Mimpact,Simpact)#
plot(I,T_i)#
length(F_i)#
length(M_i)#
length(T_i)#
T_i=sum(F_i,M_i,S_i)#
length(T_i)#
T_i=rowSums(F_i,M_i,S_i)#
T_i=rowSums(rbind(F_i,M_i,S_i))#
length(T_i)#
T_i=rbind(F_i,M_i,S_i)#
T_i#
T_i=colSums(rbind(F_i,M_i,S_i))#
length(T_i)#
plot(I,T_i)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = -.05#
#
gamma_0=-20#
gamma_1=.2#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
F=beta_0+beta_1*I#
M=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
#
plot(GNP,I, typ="l", xlim=c(0,2))#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = -.05#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
F=beta_0+beta_1*I#
M=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
#
plot(GNP,I, typ="l", xlim=c(0,2))#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = #
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
F=beta_0+beta_1*I#
M=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
#
plot(GNP,I, typ="l", xlim=c(0,2))#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = 0#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,1000)#
#
F=beta_0+beta_1*I#
M=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
#
plot(GNP,I, typ="l", xlim=c(0,2))#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
F_i=beta_0+beta_1*I*Ef#
M_i=gamma_0+gamma_1*I*Em#
M_i[M_i<0]=0#
S_i=alpha_0+alpha_1*I*Es#
S_i[S_i<0]=0#
T_i=colSums(rbind(F_i,M_i,S_i))#
plot(I,T_i)#
T_i#
SI#
Ef=.1#
Em=.5#
Es=.05#
#
beta_0=30#
beta_1 = 0#
#
gamma_0=-20#
gamma_1=.1#
alpha_0=-200#
alpha_1 = .4#
#
I=seq(0,3000)#
#
F=beta_0+beta_1*I#
M=gamma_0+gamma_1*I#
SI=alpha_0+alpha_1*I#
GNP=FI+MI+SI#
#
plot(GNP,I, typ="l", xlim=c(0,2))#
#
plot(beta_0+beta_1*I, typ="l", ylim=c(0,500), xlim=c(0,1000))#
lines(gamma_0+gamma_1*I)#
lines(alpha_0+alpha_1*I)#
#
F_i=beta_0+beta_1*I*Ef#
M_i=gamma_0+gamma_1*I*Em#
M_i[M_i<0]=0#
S_i=alpha_0+alpha_1*I*Es#
S_i[S_i<0]=0#
T_i=colSums(rbind(F_i,M_i,S_i))#
plot(I,T_i)#
1-(.07+.13+.15+.23)#
mean=0#
#
sd=1#
#
log.y=rnorm(1000,mean=mean, sd=sd)#
#
y=rlnorm(10000, meanlog=mean, sdlog = sd)#
#
par(mfrow=c(1,2))#
#
hist(log.y,breaks=50, freq=FALSE)#
log.x=seq(-3,3,.01)#
#
z=dnorm(log.x,mean=mean,sd=sd)#
#
lines(log.x,z,col="red")#
#
y=rlnorm(10000, meanlog=mean, sdlog = sd)#
#
hist(y,breaks=250, xlim=c(0,10), freq=FALSE)#
#
x=seq(0,10,.01)#
z=dlnorm(x,mean=mean,sd=sd)#
#
lines(x,z, col="red")#
#
mean(y)#
#
var(y)#
#
#you may need to use 1,000,000 draws for this to come out perfectly#
#
median=exp(mean)#
#
mean.y = exp(mean+sd^2/2)#
#
var.y = (exp(sd^2)-1)*exp(2*mean+sd^2)#
#
mean.y#
#
var.y#
sigma=sqrt(var.y)#
#
mu=mean.y#
#
#sdlog (beta)#
#
2^(1/2)*log((sigma^2+mu^2)^(1/2)/mu)^(1/2)#
#
#meanlog (alpha)#
#
round(log(mu^2/(sigma^2+mu^2)^(1/2)),digits=5)#
set.seed(1)#
library(actuar)#
varsigma.sq=25#
mu=100#
n=10#
y=rnorm(n,mu,sqrt(varsigma.sq))#
#
#normal likelihood with normal prior conjugate relationship for mean, assuming variance is known.#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
#
#
z=draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=varsigma.sq,y=y)#
#check against approximation#
sd(y)/sqrt(length(y))#
sqrt(z$sigma.sq_1)#
#
#
#normal likelihood with gamma prior conjugate relationship for variance, assuming mean is known#
draw_var =  function(alpha_0,beta_0,theta,y){#
	alpha_1 = alpha_0 + length(y)/2#
	beta_1 = beta_0 + sum((y-theta)^2) / 2#
	z=rinvgamma(1, alpha_1, scale=beta_1)  #note that this parameterization assumes that beta_1 is the *scale* parameter#
	param = list(z=z,alpha_1=alpha_1,beta_1=beta_1)#
	browser()#
	return(param)#
}#
#
#
w=draw_var(alpha_0=.001,beta_0=.001,theta=mu,y=y)#
#mean of distribution of varsigma#
w$beta_1/(w$alpha_1 + 1)  # mean of inverse-gamma distribution#
#
#note that uniformative priors for gamma distribution are not recommended. See Gelman paper in /pdfs director.  Instead, recommends uniform or half normal distribtuions on standard deviation rathter than gammas.  #
#
n.iter=10000#
n.chains = 3#
pvar = matrix(nrow = n.chains, ncol=n.iter)#
pmean = matrix(nrow = n.chains, ncol = n.iter)#
#
#initial values#
pmean[1:3,1] =c (1, 20, 50)#
pvar[1:3,1] =c(.1,5,10)#
#
#
for(t in 2:n.iter){#
	for (j in 1:n.chains){#
		pmean[j,t] = draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=pvar[j, t-1],y=y)$z#
		pvar[j,t] = draw_var(alpha_0=.001,beta_0=.001,theta=pmean[j,t],y=y)$z#
	}		#
	}#
burnin=1000#
x=seq(burnin,n.iter)#
plot(x,pvar[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pvar[2, x],typ="l", col="green")#
lines(x,pvar[3,x],typ="l", col="red")#
hist(pvar[,x],breaks=100, freq=FALSE, main=expression(varsigma^2))#
lines(density(pvar[,x]),col="red")#
abline(v=mean(pvar[,x]),lty="dashed", col="blue")#
#
plot(x,pmean[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pmean[2, x],typ="l", col="green")#
lines(x,pmean[3,x],typ="l", col="red")#
hist(pmean[,x],breaks=200, freq=FALSE, main=expression(mu),xlim=c(90,110))#
lines(density(pmean[,x]),col="red")#
abline(v=mean(pmean[,x]),lty="dashed", col="blue")#
#
rowMeans(pmean)#
apply(pmean[,x],1,sd)  # standard deviation of mean of each chain#
sd(y)/sqrt(length(y)) #approximate standard deviation based on data#
#
set.seed(1)#
library(actuar)#
varsigma.sq=25#
mu=100#
n=10#
y=rnorm(n,mu,sqrt(varsigma.sq))#
#normal likelihood with normal prior conjugate relationship for mean, assuming variance is known.#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1)#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
x#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1)#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	#sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	#mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	#sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z,mu_1=mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z,mu_1=mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z, =mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z,mu_1=mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
z=draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=varsigma.sq,y=y)#
#check against approximation#
sd(y)/sqrt(length(y))#
sqrt(z$sigma.sq_1)#
set.seed(1)#
library(actuar)#
varsigma.sq=25#
mu=100#
n=100#
y=rnorm(n,mu,sqrt(varsigma.sq))#
#
#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z,mu_1=mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
#
#
z=draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=varsigma.sq,y=y)#
#check against approximation#
sd(y)/sqrt(length(y))#
sqrt(z$sigma.sq_1)#
#normal likelihood with gamma prior conjugate relationship for variance, assuming mean is known#
draw_var =  function(alpha_0,beta_0,theta,y){#
	alpha_1 = alpha_0 + length(y)/2#
	beta_1 = beta_0 + sum((y-theta)^2) / 2#
	z=rinvgamma(1, alpha_1, scale=beta_1)  #note that this parameterization assumes that beta_1 is the *scale* parameter#
	param = list(z=z,alpha_1=alpha_1,beta_1=beta_1)#
	browser()#
	return(param)#
}#
w=draw_var(alpha_0=.001,beta_0=.001,theta=mu,y=y)#
#mean of distribution of varsigma#
w$beta_1/(w$alpha_1 + 1)  # mean of inverse-gamma distribution#
Q#
#normal likelihood with gamma prior conjugate relationship for variance, assuming mean is known#
draw_var =  function(alpha_0,beta_0,theta,y){#
	alpha_1 = alpha_0 + length(y)/2#
	beta_1 = beta_0 + sum((y-theta)^2) / 2#
	z=rinvgamma(1, alpha_1, scale=beta_1)  #note that this parameterization assumes that beta_1 is the *scale* parameter#
	param = list(z=z,alpha_1=alpha_1,beta_1=beta_1)#
	#browser()#
	return(param)#
}#
w=draw_var(alpha_0=.001,beta_0=.001,theta=mu,y=y)#
#mean of distribution of varsigma#
w$beta_1/(w$alpha_1 + 1)  # mean of inverse-gamma distribution#
n.iter=10000#
n.chains = 3#
pvar = matrix(nrow = n.chains, ncol=n.iter)#
pmean = matrix(nrow = n.chains, ncol = n.iter)#
#
#initial values#
pmean[1:3,1] =c (1, 20, 50)#
pvar[1:3,1] =c(.1,5,10)#
for(t in 2:n.iter){#
	for (j in 1:n.chains){#
		pmean[j,t] = draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=pvar[j, t-1],y=y)$z#
		pvar[j,t] = draw_var(alpha_0=.001,beta_0=.001,theta=pmean[j,t],y=y)$z#
	}		#
	}#
burnin=1000#
x=seq(burnin,n.iter)#
plot(x,pvar[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pvar[2, x],typ="l", col="green")#
lines(x,pvar[3,x],typ="l", col="red")#
hist(pvar[,x],breaks=100, freq=FALSE, main=expression(varsigma^2))#
lines(density(pvar[,x]),col="red")#
abline(v=mean(pvar[,x]),lty="dashed", col="blue")#
#
plot(x,pmean[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pmean[2, x],typ="l", col="green")#
lines(x,pmean[3,x],typ="l", col="red")#
hist(pmean[,x],breaks=200, freq=FALSE, main=expression(mu),xlim=c(90,110))#
lines(density(pmean[,x]),col="red")#
abline(v=mean(pmean[,x]),lty="dashed", col="blue")#
#
rowMeans(pmean)#
apply(pmean[,x],1,sd)  # standard deviation of mean of each chain#
sd(y)/sqrt(length(y)) #approximate standard deviation based on data#
set.seed(1)#
library(actuar)#
varsigma.sq=25#
mu=100#
n=10000#
y=rnorm(n,mu,sqrt(varsigma.sq))#
#
#
draw_mean = function(mu_0,sigma.sq_0,varsigma.sq,y){#
	mu_1 =( (mu_0 / sigma.sq_0 + sum(y)/varsigma.sq)) / (1/sigma.sq_0 + length(y)/varsigma.sq)#
	sigma.sq_1 = 1/(1/sigma.sq_0 + length(y)/varsigma.sq)#
	z = rnorm(1,mu_1,sqrt(sigma.sq_1))#
	param = list(z=z,mu_1=mu_1,sigma.sq_1=sigma.sq_1)#
	#browser()#
	return(param)#
}#
#
#
#
z=draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=varsigma.sq,y=y)#
#check against approximation#
sd(y)/sqrt(length(y))#
sqrt(z$sigma.sq_1)#
#
#
#normal likelihood with gamma prior conjugate relationship for variance, assuming mean is known#
draw_var =  function(alpha_0,beta_0,theta,y){#
	alpha_1 = alpha_0 + length(y)/2#
	beta_1 = beta_0 + sum((y-theta)^2) / 2#
	z=rinvgamma(1, alpha_1, scale=beta_1)  #note that this parameterization assumes that beta_1 is the *scale* parameter#
	param = list(z=z,alpha_1=alpha_1,beta_1=beta_1)#
	#browser()#
	return(param)#
}#
#
#
w=draw_var(alpha_0=.001,beta_0=.001,theta=mu,y=y)#
#mean of distribution of varsigma#
w$beta_1/(w$alpha_1 + 1)  # mean of inverse-gamma distribution#
#
#note that uniformative priors for gamma distribution are not recommended. See Gelman paper in /pdfs director.  Instead, recommends uniform or half normal distribtuions on standard deviation rathter than gammas.  #
#
n.iter=10000#
n.chains = 3#
pvar = matrix(nrow = n.chains, ncol=n.iter)#
pmean = matrix(nrow = n.chains, ncol = n.iter)#
#
#initial values#
pmean[1:3,1] =c (1, 20, 50)#
pvar[1:3,1] =c(.1,5,10)#
#
#
for(t in 2:n.iter){#
	for (j in 1:n.chains){#
		pmean[j,t] = draw_mean(mu_0 = 0, sigma.sq_0 = 1000, varsigma.sq=pvar[j, t-1],y=y)$z#
		pvar[j,t] = draw_var(alpha_0=.001,beta_0=.001,theta=pmean[j,t],y=y)$z#
	}		#
	}#
burnin=1000#
x=seq(burnin,n.iter)#
plot(x,pvar[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pvar[2, x],typ="l", col="green")#
lines(x,pvar[3,x],typ="l", col="red")#
hist(pvar[,x],breaks=100, freq=FALSE, main=expression(varsigma^2))#
lines(density(pvar[,x]),col="red")#
abline(v=mean(pvar[,x]),lty="dashed", col="blue")#
#
plot(x,pmean[1,x],typ="l", xlim=c(1000,10000), ylab=expression(varsigma^2), xlab="Iteration")#
lines(x,pmean[2, x],typ="l", col="green")#
lines(x,pmean[3,x],typ="l", col="red")#
hist(pmean[,x],breaks=200, freq=FALSE, main=expression(mu),xlim=c(90,110))#
lines(density(pmean[,x]),col="red")#
abline(v=mean(pmean[,x]),lty="dashed", col="blue")#
#
rowMeans(pmean)#
apply(pmean[,x],1,sd)  # standard deviation of mean of each chain#
sd(y)/sqrt(length(y)) #approximate standard deviation based on data#
#
rpois(0)#
rpois(100,0)#
dpois(0)#
dpois(5,0)#
dpois(1,0)#
library(xtable)#
?print#
?xtable#
library(xtable)#
library(coda)#
rm(list=ls())#
#root="/Volumes/wcnr-network/Research/Hobbs/A_Bison_Mauscript/Results"#
root =  "/Users/Tom/Documents/YNP_Bison_Manuscript/Results/"#
path = function (stem,r=root){#
return(paste(r,stem, sep=""))#
}#
#
load(path("median of z.Rdata")) #
load(path("Frequency DIC wt.Rdata"))#
load(path("phi_x_out_of_sample.Rdata"))#
load(path("prop_infect_2008.Rdata")) #
load(path("lambda_healthy.Rdata"))#
load(path("lambda_infected.Rdata"))#
#
load(path("Ntotals.Rdata"))#
load(path("diff.con.Rdata")) #
load(path("diff.pos.Rdata"))#
load(path("lambda.diff")) #
load(path("R0.Rdata"))#
load(path("prop.infect.Rdata"))#
load(path("serology.Rdata"))#
load(path("phi_x.Rdata"))#
load(path("parameter_table.Rdata"))#
load(path("Mgmt scenarios forecast table.Rdata"))#
load(path("Mgmt scenarios table.Rdata"))#
load(path("Mgmt scenarios forecast table unc.Rdata"))#
load(path("Mgmt scenarios table unc.Rdata"))#
load(path("DIC_table"))#
load(path("Posterior pred check table.Rdata"))#
print(xtable(ppc.table,align=c("l","l","l","c","c","c"),digits=2,display=c("s","s","s","fg","fg","fg")), NA.string="NA", floating=FALSE,sanitize.colnames.function = function(x) {x},include.rownames=FALSE)#
541+715+110+30#
.02*200*30#
2.6*.80+3.4#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (5)  #total number of correct answers + 1#
b=(20-5+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
#
#
a.now=3  #replace with data from class#
b.now=23#
y=dbeta(x,a.now,b.now)#
lines(x,y, col="blue")#
#
a.update=a+4   #add number of successes in class#
b.update =b+16   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black","blue", "red")#
text=c("Prior", "Curent", "Updated")#
legend(.2,15,text, col=col, lty="solid", bty="n")#
#
#
#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
text(.32,15,"95% equal tailed credible interval")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (5)  #total number of correct answers + 1#
b=(20-5+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (5)  #total number of correct answers + 1#
b=(20-5+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.2,15,text, col=col, lty="solid", bty="n")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (5)  #total number of correct answers + 1#
b=(20-5+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval", ylim=c(0,8))#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.2,15,text, col=col, lty="solid", bty="n")#
a#
b#
a = (4+1)  #total number of correct answers + 1#
b=(20-4+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
a#
b#
a/(a+b)#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
a.update#
b.update#
a#
b#
8/(8+37)#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.2,15,text, col=col, lty="solid", bty="n")#
legend(.3,8,text, col=col, lty="solid", bty="n")#
legend(.25,8,text, col=col, lty="solid", bty="n")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (4+1)  #total number of correct answers + 1#
b=(20-4+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval", ylim=c(0,8))#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.25,8,text, col=col, lty="solid", bty="n")#
#
#
#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
text(.32,15,"95% equal tailed credible interval")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (4+1)  #total number of correct answers + 1#
b=(20-4+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval", ylim=c(0,10))#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.25,8,text, col=col, lty="solid", bty="n")#
#
#
#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval")#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval",ylim=c(0,10))#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
text(.10,9,"95% BCI")#
text(.15,9,"95% BCI")#
text(.16,9,"95% BCI")#
text(.17,9,"95% BCI")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (4+1)  #total number of correct answers + 1#
b=(20-4+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval", ylim=c(0,10))#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.25,8,text, col=col, lty="solid", bty="n")#
#
#
#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval",ylim=c(0,10))#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
text(.17,9,"95% BCI")#
x=seq(0,.5,.001)#
par(mfrow=c(1,1))#
a = (4+1)  #total number of correct answers + 1#
b=(20-4+1)  #number of failures + 1#
a/(a+b)  #mean of distribution#
#
y=dbeta(x,a,b)#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval", ylim=c(0,10))#
#
#
a.now=3  #successes in class#
b.now=23-3 #failures in class#
#
a.update=a+a.now   #add number of successes in class#
b.update =b+b.now   #add number of failures in class#
#
y=dbeta(x,a.update,b.update)#
lines(x,y, col="red")#
#
col=c("black", "red")#
text=c("Prior",  "Updated")#
legend(.25,8,text, col=col, lty="solid", bty="n")#
#
#
#
plot(x,y, typ="l",xlab= "Probability of a correct answer", ylab="Probability density", main="Definition of confidence interval",ylim=c(0,10))#
abline(v=qbeta(.025,a.update,b.update), lty="dashed");qbeta(.025,a.update,b.update)#
abline(v=qbeta(.975,a.update,b.update), lty="dashed");qbeta(.975,a.update,b.update)#
text(.20,9,"95% BCI")#
R code:#
shape_from_stats <- function(mu = mu.global, sigma = sigma.global){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#
#
#
#[1]  9.2 13.8#
#
s=shape_from_stats(mu=.4,sigma=.1)#
x=seq(0,1,.001)#
y=dbeta(x,s[1],s[2])#
plot(x,y,,typ="l", xlab="p", ylab="P(p|y)", cex.lab=2.0,, xlim=c(0,1), ylim=c(0,6))#
abline(v=(.4),lty="dashed")#
#
R code:#
shape_from_stats <- function(mu = mu.global, sigma = sigma.global){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#
#
#
#[1]  9.2 13.8#
#
s=shape_from_stats(mu=.4,sigma=.1)#
x=seq(0,1,.001)#
y=dbeta(x,s[1],s[2])#
plot(x,y,,typ="l", xlab="p", ylab="[p|y]",  xlim=c(0,1), ylim=c(0,6))#
abline(v=(.4),lty="dashed")#
#
a.new=9.2+15#
b.new=13.8+5#
mu.new=a.new/(a.new+b.new)#
a.new#
b.new#
y=dbeta(x,a.new,b.new)#
lines(x,y)#
abline(v=mu.new,lty="dashed")#
R code:#
shape_from_stats <- function(mu = mu.global, sigma = sigma.global){#
		 a <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
		 b <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
		shape_ps <- c(a,b)#
		return(shape_ps)#
}#
#
#
#
#[1]  9.2 13.8#
#
s=shape_from_stats(mu=.4,sigma=.1)#
x=seq(0,1,.001)#
y=dbeta(x,s[1],s[2])#
plot(x,y,,typ="l", xlab="p", ylab="[p|y]",  xlim=c(0,1), ylim=c(0,6))#
abline(v=(.4),lty="dashed")#
#
a.new=9.2+15#
b.new=13.8+5#
mu.new=a.new/(a.new+b.new)#
a.new#
b.new#
y=dbeta(x,a.new,b.new)#
lines(x,y, col="red")#
abline(v=mu.new,lty="dashed")#
rm(list=ls())#
#
#simulate 100 observations of Nitrogen concentration from plots#
set.seed(1)#
obs<-rlnorm(100,.015,.005)#
#
#Function for moment matching a lognormal distribution#
mm=function(mu,sigma){#
  alpha=log(mu)-(.5*log((sigma^2+mu^2)/(mu^2)))#
  beta=sqrt(log((sigma^2+mu^2)/(mu^2)))#
  return=c(alpha,beta)#
}#
#ok--this is the first problem.  The random variable is a proportion (g / g dry matter) so you need to use a beta distribution.#
#
#set up sequences for parameters to vary#
mu=seq(.001,.03,length.out=100)#
sigma=seq(0.001,.007,length.out=100)#
#
L=matrix(0,nrow=length(mu),ncol=length(sigma))#
#
#
Tot_LL=function(pred, mmln){#
  Like.vector=plnorm(pred,mmln)#
  return(prod((Like.vector[is.finite(Like.vector)])))#
}#
#
#
#
for(i in 1:length(mu)){#
  for(j in 1:length(sigma)){#
    L[i,j]=Tot_LL(obs,mm(mu[i],sigma[j]))#
  }#
}#
#
L#
persp(mu,sigma,L)#
filled.contour(mu,sigma,L,color=terrain.colors)#
# Set seed value#
set.seed(1)#
#
numObs=100#
muObs=.015#
sigmaObs=.005#
#
#
#
############################################
###### Establish Functions #################
#
###### Beta Moment Matching Function #######
#
matchingBetaFnc <- function(mu, sigma){#
  #
  # Alpha Value#
  alpha <-(mu^2-mu^3-mu*sigma^2)/sigma^2#
  #
  # Beta Value#
  beta <- (mu-2*mu^2+mu^3-sigma^2+mu*sigma^2)/sigma^2#
#
  # Return values for alpha and beta#
  return(list(alpha=alpha,beta=beta))#
  }#
#
###### Likelihood Function #######
#
likelihoodEstFnc <- function(yDatF, alphaF, betaF){#
  #
  # Likelihood of mu and sigma given data#
  outLikeEst=prod(dbeta(yDatF, alphaF, betaF))#
  #
  # Return likelihood#
  return(outLikeEst)#
  }#
#
##################################
#
#
#
########################################
###### Simulation for Fake Data ########
#
# Match Moments for beta function to simulate data#
simOut<-matchingBetaFnc(muObs, sigmaObs)#
#
# Generate Data from a Beta Distribution#
dat<-rbeta(n=numObs, shape1=simOut$alpha, shape2=simOut$beta)#
#
# Plot Data#
par(mfrow=c(2,1),mar=c(3, 3, 1, 1))#
boxplot(dat, horizontal=TRUE,xaxt='n')#
hist(dat,breaks=100,main=NULL,xlab=NULL)#
#
#
###### Parameters to Evaluate in Likelihood #######
#
muSim=seq(.001,.03,length.out=numObs)#
sigmaSim=seq(0.001,.007,length.out=numObs)#
#
#
#######################################
###### Estimate the Likelihood ########
#
# Establish out matrix#
outLikeMatrix<-matrix(nrow=length(muSim),ncol=length(sigmaSim))#
#
#Loop for Columns (Sigma)#
for(j in 1:length(sigmaSim)){#
#
  #Loop for Rows (Mu)#
  for(i in 1:length(muSim)){#
    #
  # Match moments of inputs for mu[i] and sigma[j]#
  # Return moments for use in likelihood function  #
  outM=matchingBetaFnc(muSim[i],sigmaSim[j])#
  #
  #Estimate likelihood#
  outLikeMatrix[i,j]=likelihoodEstFnc(dat,outM$alpha,outM$beta)#
  }#
#
  # Clean up#
  rm(outM)#
}#
#
max.Value = which(outLikeMatrix==max(outLikeMatrix),arr.ind=TRUE)#
#
mu.MLE<-muSim[max.Value[1]]#
sigma.MLE<-sigmaSim[max.Value[2]]#
#
print(mu.MLE)#
print(sigma.MLE)#
###### Plot the Results #######
#
persp(muSim,sigmaSim,outLikeMatrix)#
#
filled.contour(muSim,sigmaSim,outLikeMatrix, color=terrain.colors)#
dnorm(50,40,10)#
y=c(.32.,.32.,.15,.12,.21)#
y=c(.32,.32.,.15,.12,.21)#
y=c(.32,.32,.15,.12,.21)#
prod(y,.221,sqrt(.0061))#
prod(dnorm(y,.221,sqrt(.0061)))#
prod(dnorm(y,.221,sqrt(.0061))) *dnorm(.221|0,10)#
prod(dnorm(y,.221,sqrt(.0061))) *dnorm(.221|0,sqrt(10))#
prod(dnorm(y,.221,sqrt(.0061))) * dnorm(.221|0,sqrt(10))#
y=c(.32,.32,.15,.12,.21)#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))* dnorm(.221,0,10)#
prod(dnorm(y,.221,sqrt(.0061))) * dnorm(.221|0,sqrt(100))#
prod(dnorm(y,.221,sqrt(.0061))) * dnorm(.221|0,10)#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))#
dnorm(.221|0,10)#
dnorm(.221,0,10)#
prod(dnorm(y,.221,sqrt(.0061))) * dnorm(.221,0,10)#
prod(dnorm(y,mean=.221, sd = sqrt(.0061) ))* dnorm(.221,0,10)#
prod(dnorm(y,mean=.171, sd = sqrt(.0061) ))* dnorm(.171,0,10)#
a=dgamma(.221, .191^2/.0061,.191/.0061)   #current cond on prop#
b=dgamma(.191, .221^2/.0061,.221/.0061) #prop cond on current#
#
a/b*2.51/7.89#
a#
b#
2.51/7.89*4.07/5.39#
rm(list=ls())#
library(rjags)#
J=4#
#
alpha =200#
beta =50#
sigma=.1#
prec.sigma=1/sigma^2#
varsigma = .05#
prec.varsigma=1/varsigma^2#
#
g=function(alpha,beta,x){#
		y=alpha*x/(beta+x)#
		return(y)#
}#
#
x=seq(20,300,5)#
#
plot(x,g(alpha=alpha,beta=beta,x))#
#
y=numeric(length(x))#
med=numeric(length(x))#
z=numeric(length(x))#
y=matrix(nrow=length(x), ncol=J)#
for(i in 1:length(x)){#
	med[i]=g(alpha=alpha,beta=beta, x=x[i])#
	z[i]=rlnorm(1,log(med[i]),varsigma)#
	for(j in 1:J){#
		y[i,j]=rlnorm(1,log(z[i]), sigma)#
		}#
		#
	}#
		#
matplot(x,y)#
data=list(n=length(x),J=J, y=y,x=x)#
sink("Box_7_4")#
cat("#
#
model{#
#
for(i in 1:n){#product expression over i, n must be given as data#
#
#
#
#definition of function g()#
#
med[i] <- alpha*x[i]/(beta+x[i]) #
z[i] ~ dlnorm(log(med[i]),prec.varsigma)#
#
for(j in 1:J){ #product expression over j, J must be given as data#
#
#part a, data model#
#
y[i,j] ~ dlnorm(log(z[i]),prec.sigma) #
#
#part b, process model#
#
#
} # end of j product#
#
} #end of i product#
#
#priors#
#
alpha ~ dunif(0,500) #part c#
#
beta ~ dunif(0,200) #part d#
#
prec.sigma ~ dgamma(.001,.001) #part e#
#
prec.varsigma ~ dgamma(.001,.001) #part f#
#
} #end of model#
#
",fill=TRUE)#
sink()#
jm=jags.model("Box_7_4",data=data, n.chains=1)#
z=coda.samples(jm,variable.names=c("alpha", "beta", "prec.sigma", "prec.varsigma"),n.iter=30000)#
#
dgamma(.8.608^2,.608)#
dgamma(.8,.608^2,.608)#
#
dgamma(.608,.8^2,.8)#
=1/2.2#
1/2.2#
file.choose()#
expenses=c(7600,10147,8098,3988,10206,6552,10052,6812,7458,9856,6588,6572,4936)#
e=c(7600,10147,8098,3988,10206,6552,10052,6812,7458,9856,6588,6572,4936)#
m=length(e)#
total=sum(e)-m*2890#
total/m#
(1193+5093)-total/m#
(26000+16000)*70/12#
(26000+16000)*.70/12#
#
100000*1.025^6+36000+6000+25000+40000#
(100000*1.025^6+36000+6000+25000+40000)*.75/12#
#

library(geoR)#
library(maps)#
library(mvtnorm)#
library(rjags)#
library(spBayes)#
library(rgdal)#
library(maptools)#
setwd("/Users/Tom/Documents/NSF Statistics Workshop/2015 course/Spatial statistics/Day_8_PM_Lab/")#
#
#####
####  Change Projection to UTM#
#####
#
ut.st=map("state",regions="utah",fill=T,plot=F)#
ut.coords=cbind(ut.st$x,ut.st$y)#
plot(ut.coords,type="b")#
ut.coords=rbind(ut.coords,ut.coords[1,])#
ut.latlon=SpatialPoints(ut.coords,proj4string=CRS("+proj=longlat +datum=WGS84"))#
str(ut.latlon)#
ut.utm=spTransform(ut.latlon,CRS("+proj=utm +zone=12  +datum=WGS84"))#

plot(ut.utm)#

ut.range=ut.utm@bbox#
xg=seq(ut.range[1],ut.range[3],,25)#
yg=seq(ut.range[2],ut.range[4],,30)#
utgrid.locs=as.matrix(expand.grid(xg,yg))#
plot(utgrid.locs,pch=20,asp=1,xlab="x.utms",ylab="y.utms")#
points(ut.utm@coords,type="l",lwd=3)#
ntot=dim(utgrid.locs)[1]#

head(d)#

head(D)#

class(D)#

D=as.matrix(dist(utgrid.locs))#

class(D)#

head(D)#

s2=2#
phi=1.5*10^-5#
Sigma=s2*exp(-D*phi)#
plot(seq(0,max(D),,20),s2*exp(-seq(0,max(D),,20)*phi),type="o",ylab="cov",xlab="distance")#
#

set.seed(13)#
eps=as.vector(rmvnorm(1,matrix(0,ntot,1),Sigma,method="chol"))     # may take some time#
image(matrix(eps,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)))#
points(ut.utm@coords,type="l",lwd=3)#

idxkeep=sort(sample(1:ntot,round(0.4*ntot)))#
epsmask=matrix(0,ntot,1)#
epsmask[idxkeep,]=1#
image(matrix(eps,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),asp=TRUE)#
image(matrix(epsmask,length(xg),length(yg)),x=xg,y=yg,col=c("white","transparent"),asp=TRUE,add=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#

#####
####  Examine empirical spatial structure in simulated process#
#####
#
n=length(idxkeep)#
utgrid.sm.locs=utgrid.locs[idxkeep,]#
eps.gd=as.geodata(cbind(utgrid.sm.locs,eps[idxkeep]))#
#
eps.v=variog(eps.gd,max.dist=max(D))#
plot(eps.v)#
lines(eps.v$uvec,s2-s2*exp(-eps.v$uvec*phi),type="o",pch=20)#
#

p=3#
X=matrix(1,ntot,p)#
X[,2]=-cos(scale(utgrid.locs[,1])-.5)*cos(scale(utgrid.locs[,2]))#
X[,3]=scale(utgrid.locs[,1])+scale(utgrid.locs[,2])#
#
beta=c(1,-2,1)#
y=X%*%beta+eps#

layout(matrix(1:4,2,2))#
image(matrix(y,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="y",asp=TRUE)#
image(matrix(epsmask,length(xg),length(yg)),x=xg,y=yg,col=c("white","transparent"),asp=TRUE,add=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(eps,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="epsilon",asp=TRUE)#
image(matrix(epsmask,length(xg),length(yg)),x=xg,y=yg,col=c("white","transparent"),asp=TRUE,add=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(X[,2],length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main=bquote(x[1]),asp=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(X[,3],length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main=bquote(x[2]),asp=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#

y.sm=y[idxkeep]#
X.sm=X[idxkeep,]#
D.sm=D[idxkeep,idxkeep]#
min.prior.range=max(D.sm)/500#
max.prior.range=max(D.sm)#
data=list(y = y.sm, X = X.sm, n = n, p = p, D = D.sm,min.prior.range=min.prior.range,max.prior.range=max.prior.range)#
inits <- list(beta = rep(0,p), tau = .5, phi = 2*10^-5 )#
var.names <- c("beta","phi","tau")#
#
jags.sp.m <- jags.model(file = "lab_8_jags_model.txt", data = data, inits = inits, n.chains = 1, n.adapt = 0)#
jags.out <- jags.samples(model=jags.sp.m,variable.names=var.names,n.iter=1000)#
#
par(mfrow=c(2,3))#
for(i in 1:p){#
  plot(jags.out$beta[i,,1],type="l",col=i,main=paste(c("beta",i-1)))#
  abline(h=beta[i],lwd=3)#
}#
plot(jags.out$phi[1,,1],type="l",col=4,main="phi")#
abline(h=phi,lwd=3)#
plot(1/jags.out$tau[1,,1],type="l",col=5,main="Sigma^2")#
abline(h=s2,lwd=3)#
#

starting <- list("phi"=4/max(D), "sigma.sq"=1)#
tuning <- list("phi"=.1, "sigma.sq"=.1)#
priors <- list("beta.Flat", "phi.Unif"=c(3/max.prior.range, 3/min.prior.range),"sigma.sq.IG"=c(2, 5))#
cov.model <- "exponential"#
#
m.1 <- spLM(y.sm~0+X.sm, coords=utgrid.sm.locs, starting=starting, tuning=tuning,priors=priors, cov.model=cov.model, n.samples=10000)#
#

m.1.betas <- spRecover(m.1,get.w=FALSE)#
#
layout(matrix(1:3,3,1))#
plot(m.1.betas$p.theta.samples[,1],type="l",lty=1)  # Check convergence for covariance parameters#
abline(v=c(s2),col=8,lwd=2)#
plot(m.1.betas$p.theta.samples[,2],type="l",lty=1)  # Check convergence for covariance parameters#
matplot(m.1.betas$p.beta.recover.samples,type="l",lty=1)  # Check convergence for covariance parameters#
abline(h=beta,col=8,lwd=2)#
#

m.1.pred <- spPredict(m.1, pred.covars=X, pred.coords=utgrid.locs, start=2000)#
y.pred=apply(m.1.pred$p.y.predictive.samples, 1, mean)#
y.pred.sd=apply(m.1.pred$p.y.predictive.samples, 1, sd)#
#
layout(matrix(1:4,2,2))#
image(matrix(y,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="y truth",asp=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(y,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="y data",asp=TRUE)#
image(matrix(epsmask,length(xg),length(yg)),x=xg,y=yg,col=c("white","transparent"),asp=TRUE,add=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(y.pred,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="y prediction",asp=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#
image(matrix(y.pred.sd,length(xg),length(yg)),x=xg,y=yg,col=rev(rainbow(100,start=0,end=.7)),main="prediction sd",asp=TRUE)#
points(ut.utm@coords,type="l",lwd=3)#

font#

